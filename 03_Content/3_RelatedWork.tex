\chapter{Related Work}
The inherently low arithmetic intensity of stencil codes made their optimization a long-standing research topic.
For traditional \ac{hpc} architectures, like \ac{cpu} and \ac{gpu}, most work focuses on cache optimization by using techniques like tiling, loop reordering or temporal blocking, that increases the effective arithmetic intensity and shift the problem more towards being compute-bound.
\textcite{lange2016devito} introduced Devito, a python based \ac{dsl} for finite difference stencil codes, that generates code for different \ac{hpc} architectures, incorporating these techniques \cite{lange2016devito}.

However, new hardware accelerators like the \ac{wse} feature a vastly different programming model with \acp{pe} representing indendent hardware units with a lack of synchronized control and a completly missing cache hierarchy. This makes most studied ideas not applicable and left the limiting factors of stencil codes on the \ac{wse} underexplored and too difficult to target for general-purpose stencil \ac{dsl}s like Devito.

\textcite{rocki2020fast} were the first to use the \ac{wse} architecture for stencil computations and layed the foundation for how the memory access in stencil patterns can be replaced by communication between \ac{pe}s holding parts of the grid \cite{rocki2020fast}.

\textcite{jacquelin2022massively} implement and analyze a 25-point 3D stencil on the \ac{wse}-2.
They do this by mapping the z-dimension of the grid to the \ac{pe}s memory while mapping the x and y dimensions to the \ac{wse}-2's \ac{pe}s, so that each \ac{pe} holds a 1D column of the grid.
Noticably they show almost perfect weak scaling with the an increasing number of \ac{pe}s, meaning that when the number of \ac{pe}s is increased from \numproduct{200 x 200} to the full \ac{wse}-2's maximum dimension of \numproduct{755 x 994} while increasing the problem size by the same factor, the runtime is almost constant with only a 1.5\% increase \cite{jacquelin2022massively}.

There have also been apporaches for compiling higher level stencil languages to code for the \ac{wse} as presented by \textcite{woo2022disruptive} and \textcite{sai2024automated} \cite{woo2022disruptive,sai2024automated}. However, these approaches focus on 3D stencils and while they might be able to generate code for 2D stencils, they don't explore topics like tiling of the x and y dimensions. While this idea is less practical for most 3D stencil applications, it is a lot more promising for 2D stencils and therefore the focus of our work.

Existing work analyzes only one specific stencil pattern at a time and does not explore the effects of different radii, directly comparing low-order and high-order stencil patterns on the \ac{wse}.