\chapter{Related Work}
The inherently low arithmetic intensity of stencil codes made their optimization a long-standing research topic.
Most work for traditional \ac{hpc} architectures like \ac{cpu} and \ac{gpu} focuses on cache optimization by using techniques like tiling, loop transformations or temporal blocking, that increases the effective arithmetic intensity and shift the problem more towards being compute-bound.
Tiling improves the cache utilization by splitting the problem domain spatially into parts, so that cached values can be used for as many updates as possible.
Tiling can be implemented hierarchically for all cache levels.
Temporal blocking takes the concept of tiling a step further by performing multiple iterations on a single tile before moving to the next tile.
Bringing all of these techniques together for a specific application is inherently complex and requires careful tuning, taking into accounst the specific hardware cache sizes, the problem size and stencil layout.
This raised the need for specialized stencil compilers.
One of these is Devito, a python based \ac{dsl} for finite difference stencil codes, that generates code for different \ac{hpc} architectures, incorporating various optimization techniques \cite{lange2016devito}. 
Other systems include Tiramisu, ExaStencils and Pochoir which uses a divide-and-conquer algorithm to make it oblivious to the cache size \cite{baghdadi2019tiramisu,lengauer2014exastencils,tang2011pochoir}.

However, new hardware accelerators like the \ac{wse} feature a vastly different programming model with \acp{pe} representing independent hardware units with a lack of synchronized control, distributed memory and a completly missing cache hierarchy. 
This makes most studied ideas not applicable and left the limiting factors of stencil codes on the \ac{wse} underexplored and too difficult to target for general-purpose stencil compilers.

\textcite{rocki2020fast}\cite{rocki2020fast} were the first to use the \ac{wse} architecture for stencil computations and showcased an efficient 7-point 3D stencil for finite differences.
They laid the foundation for how the memory access in stencil patterns can be replaced by communication between \ac{pe}s holding parts of the grid. They do this by mapping the z-dimension of the grid to the \ac{pe}s memory while mapping the x and y dimensions to the \ac{wse}-2's \ac{pe}s, so that each \ac{pe} holds a 1D column of the grid.
Building on this work, \textcite{jacquelin2022massively}\cite{jacquelin2022massively} implement and analyze a more complex 25-point 3D stencil on the \ac{wse}-2. Different than the work done by \textcite{rocki2020fast}, this stencil requires multi-hop communication, which involves complex dynamic routing configurations.
Noticably they show almost perfect weak scaling with an increasing number of \ac{pe}s, meaning that when the number of \ac{pe}s is increased from \numproduct{200 x 200} to the full \ac{wse}-2's maximum dimension of \numproduct{755 x 994} while increasing the problem size by the same factor, the runtime is almost constant with only a 1.5\% increase.

There have also been apporaches working on abstracting away as much complexity as possible and automatically generate \ac{csl} from a higher level \ac{api} or stencil \ac{dsl} as presented by \textcite{woo2022disruptive}\cite{woo2022disruptive} and \textcite{sai2024automated}\cite{sai2024automated}. However, these approaches focus on 3D stencils and while they might be able to generate code for 2D stencils, they don't explore topics like tiling of the x and y dimensions. While this idea is less practical for most 3D stencil applications, it is a lot more promising for 2D stencils and therefore the focus of our work. We furthermore systematically analyze the performance implications of different tile sizes and radii, directly comparing low-order and high-order stencil patterns on the \ac{wse}.