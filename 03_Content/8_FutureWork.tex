\chapter{Discussion and Future Work}
While we show that the \ac{wse} can be used effectively to accelerate two-dimensional stencil codes and how tiling across the x and y dimensions can be used to achieve higher throughput, a lot more work is needed to further optimize the performance, extend the approach to other stencil patterns and automizing code generation for the \ac{wse}.

\section{Performance and Kernel-Level Optimizations}
There are several possible ways to further optimize our proposed implentation.
First, implementing strict overlap between communication and computation would lead to increased utilization of the available compute resources and increase the throuput, especially for larger radii.
For the most outer row or column of the halo region, this could be easily by multiplying the values while receiving directly with the specific coefficient and adding the results to the accumulator. In the computation step, the \acp{dsd} could be cropped to only include not yet computed values. However for the general case with a radius greater than one, multiple grid values depend on the same third grid value, making this problem highly complex. To take this idea one step further, computation can also be done while sending the data, but it is unclear if it would even be theoretically possible to reorganize the compute in the necessary way.

Furthermore, we couln't achive full \ac{simd} width for the \texttt{@fadds} instruction and even for the \texttt{@fmacs} instruction that has a maximum \ac{simd} width of one, we could not achieve a sustained throughput of one operation per cycle. Full \ac{simd} width can only be archived if the two source operands lie on banks that don't conflict with each other. The bank number in which data lies only depends on the absolute memory address, so that bank conlicts can be avoided by having specific offsets between the addresses of operands. In the current implementation however, different regions within the buffer with offsets between 0 and $r$ in x and y direction relative to the center are added to the accumulator which has a fixed address. This necessarily creates operations where bank conflics occur. A tile-size dependend padding could probaply decrease the number of conflics a bit and a "sparse buffer" which skips memory address by only using every nth element might further reduce or even eliminate conflicts. In limited experiments we couln't achive full \ac{simd} width using \texttt{mem4d\_dsd}s, even in settings with no bank conflicts. We are not sure if this might have been caused by inherent limitations of \texttt{@mem4d\_dsd}s or other factors.

We explored the potential of optimization by trading \texttt{@fmacs} instructions for \texttt{@fadds} and \texttt{@fmuls} instructions for problems with symmetric coefficients in the r1-optimized implementation. The logical next step would be to dynamically recognize if symmetric coefficients are used and switch to  this more efficient implementation, which would reduce the cycles per cell from four to three on \ac{wse}-2 and two on \ac{wse}-3 respectively.

Overhead could be further reduced by strictly using explicit \ac{dsr} assignment, better utilization of border \acp{pe} and more efficient logic to detect the completetion of communication, which could be done by specifying an explicit order for the different in different directions, always activating the next direction, when the previous is completed.

\section{Extending the Stencil and Problem Scope}
Our approach lays the foundation for efficient two-dimensional stencil implementations on cerebras and can be extended in several ways.
One natural way would be to support all box-shaped stencil patterns.
We believe, this could be done with only minor adjustments to our current approach.
While the computation would require values from the diagonal neighbors, we could create a strict ordering for the four axial directions and configure the program in a way that it always sends the relevant part of the just received halo region to the next \ac{pe}, requiring the same communication steps and routing configuration as already implemented.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{plot_data_exchange_box_shaped.png}
    \caption{Data exchange for a possible box-shaped stencil pattern. The left shows the state after north to south and south to north communication is completed, the right shows the state after all four directions are completed, directly receiving the data from the just filled halo region of the neighbor.}
    \label{fig:data_exchange_box_shaped}
\end{figure}

Although multi-hop communication could be implemented to allow a large radius while using a small tile size, the benefit propaply wouldn't justify the additional complexity in the routing logic and the additional communication steps. Using larger tile sizes, which we found in general to be more efficient, multi-hop communication isn't required even for high-order stencils.

An efficient all-reduce operation... 
----- WIP -----
efficient all-reduce implementation would all be valueable extensions to make the \ac{wse} a more versatile tool for stencil computations, especially, if implemented within the context of a \ac{dsl} \cite{woo2022disruptive,sai2024automated}.


% \begin{itemize}
%     \item 
%     \item More optimization: use border \acp{pe} in a smarter way, use explicit \ac{dsr} assignment, try to overlap communication and computation in the general algorithm
%     \item try achieving full simd width (lower precision data types??)
%     \item JOR, Gauss-Seidel / Red-Black implentation and SOR method or multigrid methods
%     \item automatic convergence detection
% \end{itemize} 